<!-- =========================================
     FILE: public/flappybingus.html
     (Updated: user registration + server highscores + unlockable trails)
     ========================================= -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Flappy Bingus</title>
  <style>
    :root{
      --bg0:#070b12;
      --bg1:#0b1220;
      --panel:rgba(10,14,20,.84);
      --panel2:rgba(10,14,20,.62);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --accent:rgba(120,210,255,.95);
      --danger:rgba(255,90,90,.95);
      --ok:rgba(120,255,160,.95);
    }
    html,body{height:100%;margin:0;overflow:hidden;background:linear-gradient(180deg,var(--bg0),var(--bg1));font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text)}
    #wrap{position:fixed;inset:0}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;background:#070b12}
    .screen{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
    .panel{pointer-events:auto;width:min(920px,calc(100vw - 28px));padding:18px 18px 16px;border-radius:16px;
      background:linear-gradient(180deg,var(--panel),var(--panel2));
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);}
    .title{font-weight:950;letter-spacing:.6px;line-height:1.02;font-size:clamp(44px,6vw,74px);margin:6px 0 8px;text-shadow:0 10px 30px rgba(0,0,0,.45)}
    .sub{color:var(--muted);font-size:14.5px;line-height:1.45;margin:0 0 12px}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:14px;align-items:start}
    @media (max-width: 860px){ .grid{grid-template-columns:1fr} }
    .card{border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);padding:12px 12px 10px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;margin-top:10px}
    button{appearance:none;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.08);color:var(--text);
      padding:12px 16px;border-radius:12px;font-weight:950;font-size:16px;cursor:pointer;
      box-shadow:0 10px 24px rgba(0,0,0,.35);transition:transform .06s ease,background .12s ease}
    button:hover{background:rgba(255,255,255,.12);transform:translateY(-1px)}
    button:active{transform:translateY(0)}
    button.primary{border-color:rgba(120,210,255,.35);background:rgba(120,210,255,.14)}
    button.primary:hover{background:rgba(120,210,255,.18)}
    button[disabled]{opacity:.55;cursor:not-allowed;transform:none}
    .pill{display:inline-flex;gap:8px;align-items:center;font-size:13px;color:var(--muted);
      border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);padding:7px 10px;border-radius:999px}
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(255,200,120,.95);box-shadow:0 0 14px rgba(255,200,120,.35)}
    .pill.ok .dot{background:var(--ok);box-shadow:0 0 14px rgba(120,255,160,.35)}
    .pill.bad .dot{background:var(--danger);box-shadow:0 0 14px rgba(255,90,90,.35)}
    .pill.neutral .dot{background:rgba(170,170,170,.9);box-shadow:0 0 14px rgba(170,170,170,.25)}
    .stats{margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,.12);color:var(--muted);font-size:13.5px;line-height:1.55}
    .kbd{display:inline-block;padding:2px 7px;border-radius:8px;border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);color:rgba(255,255,255,.85);font-weight:900}
    .hidden{display:none!important}

    .field{display:flex;flex-direction:column;gap:6px}
    .lbl{font-size:12px;color:rgba(255,255,255,.72);font-weight:900;letter-spacing:.3px}
    input[type="text"], select{
      appearance:none;width:100%;padding:10px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.25);color:rgba(255,255,255,.92);font-weight:800;outline:none;
    }
    input[type="text"]::placeholder{color:rgba(255,255,255,.45)}
    .minirow{display:flex;gap:8px;align-items:center}
    .hint{font-size:12.5px;color:rgba(255,255,255,.60);line-height:1.35}
    .hint.good{color:rgba(120,255,160,.80)}
    .hint.bad{color:rgba(255,90,90,.80)}

    .hsTable{width:100%;border-collapse:collapse;font-size:13.5px}
    .hsTable th,.hsTable td{padding:8px 8px;border-bottom:1px solid rgba(255,255,255,.10);text-align:left}
    .hsTable th{color:rgba(255,255,255,.78);font-weight:950}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="menu" class="screen">
    <div class="panel">
      <div class="title">Flappy Bingus</div>
      <p class="sub">
        Register a username to track progression, unlock trails, and appear on the global leaderboard.
      </p>

      <div class="grid">
        <div class="card">
          <div class="row" style="margin-top:0">
            <button id="start" class="primary" disabled>Start</button>
            <div id="bootPill" class="pill"><span class="dot"></span><span id="bootText">Loading…</span></div>
          </div>

          <div style="height:10px"></div>

          <div class="field">
            <div class="lbl">Username</div>
            <div class="minirow">
              <input id="usernameInput" type="text" maxlength="18" placeholder="3–18 chars: letters, numbers, space, _ or -"/>
              <button id="saveUserBtn">Save</button>
            </div>
            <div id="userHint" class="hint">Not signed in.</div>
          </div>

          <div style="height:10px"></div>

          <div class="field">
            <div class="lbl">Cosmetic Trail</div>
            <select id="trailSelect"></select>
            <div id="trailHint" class="hint">Unlock trails by improving your personal best.</div>
          </div>

          <div class="stats">
            Move: <span class="kbd">W</span> <span class="kbd">A</span> <span class="kbd">S</span> <span class="kbd">D</span>.
            Skills: <span class="kbd">1</span>–<span class="kbd">4</span>.
            <br/>
            Orbs give points + combo. If any orb despawns, combo breaks.
            <br/>
            Perfect Thread: pass the exact center of a gap when it crosses you.
            <br/>
            Personal best: <span class="kbd" id="pbText">0</span> • Selected trail: <span class="kbd" id="trailText">classic</span>
          </div>
        </div>

        <div class="card">
          <div class="row" style="margin-top:0">
            <div style="font-weight:950;letter-spacing:.3px">High Scores</div>
            <a href="/highscores" style="color:rgba(120,210,255,.95);text-decoration:none;font-weight:900;font-size:13px">Full list</a>
          </div>
          <div style="height:8px"></div>
          <div id="hsWrap" class="hint">Loading leaderboard…</div>
        </div>
      </div>
    </div>
  </div>

  <div id="over" class="screen hidden">
    <div class="panel">
      <div class="title" style="color:var(--danger)">GAME OVER</div>
      <p class="sub">One collision = instant death. Gameplay is frozen.</p>
      <div class="stats">
        Final score: <span class="kbd" id="final">0</span><br/>
        Personal best: <span class="kbd" id="overPB">0</span>
      </div>
      <div class="row" style="margin-top:14px">
        <button id="restart" class="primary">Restart</button>
        <button id="toMenu">Main Menu</button>
      </div>
      <div class="stats">Shortcuts: <span class="kbd">R</span> restart, <span class="kbd">Esc</span> menu.</div>
    </div>
  </div>
</div>

<script>
"use strict";

/* ---------------- Optional local fallback best (cookie) ---------------- */
const LOCAL_BEST_COOKIE = "chocolate_chip";
function getCookie(name){
  const needle = name + "=";
  const parts = document.cookie ? document.cookie.split(";") : [];
  for (const part of parts){
    const p = part.trim();
    if (p.startsWith(needle)) return p.slice(needle.length);
  }
  return null;
}
function setCookie(name, value, days){
  const safe = String(value).replace(/[;\n\r]/g,"");
  const maxAge = Math.max(0, Math.floor(days*86400));
  document.cookie = `${name}=${safe}; Max-Age=${maxAge}; Path=/; SameSite=Lax`;
}
function readLocalBest(){
  const raw = getCookie(LOCAL_BEST_COOKIE);
  const n = Number.parseInt(raw,10);
  return (Number.isFinite(n) && n>=0) ? Math.min(n, 1e9) : 0;
}
function writeLocalBest(v){ setCookie(LOCAL_BEST_COOKIE, Math.max(0, Math.min(1e9, v|0)), 3650); }

/* ---------------- Config defaults + optional JSON ---------------- */
const DEFAULT_CONFIG = {
  player: { maxSpeed: 420, accel: 2600, friction: 16, sizeScale: 0.055, sizeMin: 28, sizeMax: 54, radiusScale: 0.38 },
  pipes: {
    difficulty: { timeToMax: 38, scoreToMax: 120, mixTime: 0.55, mixScore: 0.45 },
    spawnInterval: { start: 0.78, end: 0.23, min: 0.18, max: 0.90 },
    speed: { start: 240, end: 560 },
    thickness: { scale: 0.055, min: 28, max: 64 },
    gap: { startScale: 0.30, endScale: 0.20, min: 88, max: 190 },
    special: { startCadence: 3.8, endCadence: 2.3, jitterMin: 0.2, jitterMax: 0.7 },
    patternWeights: { wall: [0.18, 0.30], aimed: [0.26, 0.40] },
    colors: { green:"#34d399", blue:"#60a5fa", yellow:"#fbbf24", red:"#fb7185" }
  },
  skills: {
    bindings: ["dash","phase","teleport","slowField"],
    dash: { cooldown: 1.15, duration: 0.18, speed: 900 },
    phase: { cooldown: 1.75, duration: 0.40 },
    teleport: { cooldown: 2.10, range: 170, effectDuration: 0.35, burstParticles: 34 },
    slowField: { cooldown: 4.50, duration: 1.80, radius: 210, slowFactor: 0.58 }
  },
  catalysts: {
    orbs: { enabled:true, intervalMin:0.95, intervalMax:1.65, maxOnScreen:6, lifetime:10.0, radius:12, driftSpeedMin:10, driftSpeedMax:45, safeDistance:120 }
  },
  scoring: {
    pipeDodge: 1,
    orbBase: 5,
    orbComboBonus: 1,
    orbComboMax: 30,
    perfect: { enabled:true, bonus:10, windowScale:0.075, flashDuration:0.55 }
  },
  ui: { comboBar: { glowAt:8, sparkleAt:12, sparkleRate:28 } }
};

function isPlainObject(v){ return v && typeof v==="object" && !Array.isArray(v); }
function clone(o){ return JSON.parse(JSON.stringify(o)); }
function mergeKnown(base, incoming){
  if (Array.isArray(base)) return Array.isArray(incoming) ? incoming.slice() : base.slice();
  if (!isPlainObject(base)){
    if (incoming===undefined) return base;
    if (typeof base==="number"){ const n=Number(incoming); return Number.isFinite(n)?n:base; }
    if (typeof base==="boolean"){ if (incoming===true||incoming===false) return incoming; return base; }
    if (typeof base==="string"){ return (typeof incoming==="string")?incoming:base; }
    return base;
  }
  const out = {};
  const src = isPlainObject(incoming) ? incoming : {};
  for (const k of Object.keys(base)) out[k] = mergeKnown(base[k], src[k]);
  return out;
}
let CFG = clone(DEFAULT_CONFIG);

/* ---------------- Canvas + UI ---------------- */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d",{alpha:false});

const menu = document.getElementById("menu");
const over = document.getElementById("over");
const startBtn = document.getElementById("start");
const restartBtn = document.getElementById("restart");
const toMenuBtn = document.getElementById("toMenu");
const finalEl = document.getElementById("final");
const overPB = document.getElementById("overPB");
const pbText = document.getElementById("pbText");
const trailText = document.getElementById("trailText");

const bootPill = document.getElementById("bootPill");
const bootText = document.getElementById("bootText");

const usernameInput = document.getElementById("usernameInput");
const saveUserBtn = document.getElementById("saveUserBtn");
const userHint = document.getElementById("userHint");
const trailSelect = document.getElementById("trailSelect");
const trailHint = document.getElementById("trailHint");
const hsWrap = document.getElementById("hsWrap");

const boot = { imgReady:false, imgOk:false, cfgReady:false, cfgOk:false, cfgSrc:"defaults" };

/* ---------------- Server session + cosmetics ---------------- */
const net = {
  online: true,
  user: null, // {username,bestScore,selectedTrail,unlockedTrails,...}
  trails: [
    { id:"classic", name:"Classic", minScore:0 },
    { id:"rainbow", name:"Rainbow", minScore:100 },
    { id:"gothic", name:"Gothic", minScore:150 }
  ],
  highscores: []
};

function canStart(){
  // Require assets/config loaded; require user when online (so scores map to a user).
  const bootReady = boot.imgReady && boot.cfgReady;
  if (!bootReady) return false;
  if (!net.online) return true;            // allow offline play
  return !!net.user;                        // online: must be registered
}

function setBootUI(){
  startBtn.disabled = !canStart();
  bootPill.classList.remove("ok","bad","neutral");

  const ready = boot.imgReady && boot.cfgReady;
  if (!ready){
    bootPill.classList.add("neutral");
    bootText.textContent = "Loading…";
    return;
  }

  // ready
  const ok = boot.imgOk && (boot.cfgOk || !boot.cfgOk);
  bootPill.classList.add(ok ? "ok" : "bad");

  const a = boot.imgOk ? "player ok" : "player fallback";
  const b = boot.cfgOk ? boot.cfgSrc : "defaults";
  const c = net.online ? (net.user ? `user: ${net.user.username}` : "no user") : "offline";
  bootText.textContent = `${a} • ${b} • ${c}`;
}

/* ---------------- Assets ---------------- */
const playerImg = new Image();
playerImg.src = "file.png";
playerImg.onload = () => { boot.imgReady=true; boot.imgOk=true; setBootUI(); };
playerImg.onerror = () => { boot.imgReady=true; boot.imgOk=false; setBootUI(); };

/* ---------------- Optional config load ---------------- */
async function tryFetchJson(url){
  const res = await fetch(url,{cache:"no-store"});
  if (!res.ok) throw new Error("HTTP "+res.status);
  return JSON.parse(await res.text());
}
(async ()=>{
  const candidates = ["flappy_bingus_config.json","config.json"];
  let loaded=null, src="defaults";
  for (const c of candidates){
    try{ loaded = await tryFetchJson(c); src=c; break; }catch(_){}
  }
  if (loaded && isPlainObject(loaded)){
    CFG = mergeKnown(DEFAULT_CONFIG, loaded);
    boot.cfgOk = true; boot.cfgSrc = src;
  } else {
    CFG = clone(DEFAULT_CONFIG);
    boot.cfgOk = false; boot.cfgSrc = "defaults";
  }
  boot.cfgReady = true;
  setBootUI();
})();

/* ---------------- Networking ---------------- */
async function api(path, opts={}){
  try{
    const res = await fetch(path, {
      credentials: "same-origin",
      ...opts,
      headers: {
        "Content-Type": "application/json",
        ...(opts.headers||{})
      }
    });
    const data = await res.json().catch(()=>null);
    if (!res.ok || !data) throw new Error("api_fail");
    net.online = true;
    return data;
  } catch(_){
    net.online = false;
    return null;
  } finally {
    setBootUI();
  }
}

function setUserHint(){
  if (!net.online){
    userHint.className = "hint bad";
    userHint.textContent = "Server offline/unreachable. Offline play enabled (no global highscores).";
    return;
  }
  if (!net.user){
    userHint.className = "hint";
    userHint.textContent = "Enter a username to save progression and appear on the leaderboard.";
  } else {
    userHint.className = "hint good";
    userHint.textContent = `Signed in as ${net.user.username}. Runs: ${net.user.runs} • Total: ${net.user.totalScore}`;
  }
}

function fillTrailSelect(){
  const trails = net.trails || [];
  const unlocked = (net.user && net.user.unlockedTrails) ? new Set(net.user.unlockedTrails) : new Set(["classic"]);
  const selected = (net.user && net.user.selectedTrail) ? net.user.selectedTrail : "classic";

  // rebuild options
  trailSelect.innerHTML = "";
  for (const t of trails){
    const opt = document.createElement("option");
    opt.value = t.id;
    const locked = !unlocked.has(t.id);
    opt.textContent = locked ? `${t.name} (locked: ${t.minScore})` : t.name;
    opt.disabled = locked;
    trailSelect.appendChild(opt);
  }

  // set selection to first unlocked if current isn't allowed
  let sel = selected;
  if (!unlocked.has(sel)) sel = "classic";
  trailSelect.value = sel;

  trailText.textContent = sel;
  if (!net.user){
    trailHint.className = "hint";
    trailHint.textContent = "Register to unlock and persist cosmetics.";
  } else {
    trailHint.className = "hint";
    trailHint.textContent = `Unlock: Rainbow @ 100 • Gothic @ 150. Your best: ${net.user.bestScore}`;
  }
}

function renderHighscores(){
  if (!net.online){
    hsWrap.className = "hint bad";
    hsWrap.textContent = "Leaderboard unavailable (offline).";
    return;
  }
  const hs = net.highscores || [];
  if (!hs.length){
    hsWrap.className = "hint";
    hsWrap.textContent = "No scores yet. Be the first.";
    return;
  }

  hsWrap.className = "";
  const table = document.createElement("table");
  table.className = "hsTable";
  const thead = document.createElement("thead");
  thead.innerHTML = `<tr><th>#</th><th>User</th><th class="mono">Best</th></tr>`;
  table.appendChild(thead);
  const tbody = document.createElement("tbody");

  const top = hs.slice(0, 10);
  top.forEach((e,i)=>{
    const tr = document.createElement("tr");
    const isMe = net.user && e.username === net.user.username;
    tr.innerHTML = `<td class="mono">${i+1}</td><td>${escapeHtml(e.username)}${isMe?" (you)":""}</td><td class="mono">${e.bestScore|0}</td>`;
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);

  hsWrap.innerHTML = "";
  hsWrap.appendChild(table);
}

function escapeHtml(s){
  return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#39;");
}

async function refreshProfileAndHighscores(){
  const me = await api("/api/me", { method:"GET" });
  if (me && me.ok){
    net.user = me.user || null;
    net.trails = me.trails || net.trails;
  } else {
    net.user = null;
  }
  setUserHint();
  fillTrailSelect();
  pbText.textContent = String((net.user ? net.user.bestScore : readLocalBest())|0);
  trailText.textContent = String((net.user ? net.user.selectedTrail : "classic"));

  const hs = await api("/api/highscores?limit=20", { method:"GET" });
  if (hs && hs.ok) net.highscores = hs.highscores || [];
  renderHighscores();

  setBootUI();
}

saveUserBtn.addEventListener("click", async ()=>{
  const username = usernameInput.value.trim();
  const res = await api("/api/register", { method:"POST", body: JSON.stringify({ username }) });
  if (res && res.ok){
    net.user = res.user;
    net.trails = res.trails || net.trails;
    usernameInput.value = net.user.username;
    await refreshProfileAndHighscores();
  } else {
    setUserHint();
  }
});

trailSelect.addEventListener("change", async ()=>{
  const id = trailSelect.value;
  trailText.textContent = id;
  if (!net.online || !net.user){
    // offline / not logged in: just local selection for session
    return;
  }
  const res = await api("/api/cosmetics/trail", { method:"POST", body: JSON.stringify({ trailId: id }) });
  if (res && res.ok){
    net.user = res.user;
    net.trails = res.trails || net.trails;
    fillTrailSelect();
  } else {
    fillTrailSelect();
  }
});

/* ---------------- Input ---------------- */
const keys = Object.create(null);
window.addEventListener("keydown",(e)=>{
  keys[e.code]=true;
  if (["KeyW","KeyA","KeyS","KeyD","Digit1","Digit2","Digit3","Digit4","Space"].includes(e.code)) e.preventDefault();
  if (!e.repeat && state===STATE.PLAY){
    if (e.code==="Digit1") useSkill(0);
    if (e.code==="Digit2") useSkill(1);
    if (e.code==="Digit3") useSkill(2);
    if (e.code==="Digit4") useSkill(3);
  }
  if (state===STATE.OVER){
    if (e.code==="KeyR") { e.preventDefault(); startGame(); }
    if (e.code==="Escape") { e.preventDefault(); toMenu(); }
  } else if (state===STATE.PLAY){
    if (e.code==="Escape"){ e.preventDefault(); toMenu(); }
  } else if (state===STATE.MENU){
    if ((e.code==="Enter"||e.code==="Space") && !startBtn.disabled){ e.preventDefault(); startGame(); }
  }
},{passive:false});
window.addEventListener("keyup",(e)=>{ keys[e.code]=false; });

const cursor = { x:0, y:0, has:false };
function updateCursor(e){
  const r = canvas.getBoundingClientRect();
  cursor.x = (e.clientX - r.left);
  cursor.y = (e.clientY - r.top);
  cursor.has = true;
}
canvas.addEventListener("pointermove", updateCursor, {passive:true});
canvas.addEventListener("pointerdown", (e)=>{ updateCursor(e); window.focus(); }, {passive:true});

/* ---------------- Math helpers ---------------- */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const rand = (a,b)=>a+(b-a)*Math.random();
function norm2(x,y){ const l=Math.hypot(x,y); return (l>1e-9)?{x:x/l,y:y/l,len:l}:{x:0,y:0,len:0}; }
function approach(cur, tgt, md){ const d=tgt-cur; if (Math.abs(d)<=md) return tgt; return cur+Math.sign(d)*md; }
function circleRect(cx,cy,r,rx,ry,rw,rh){
  const qx = clamp(cx, rx, rx+rw);
  const qy = clamp(cy, ry, ry+rh);
  const dx=cx-qx, dy=cy-qy;
  return (dx*dx+dy*dy) <= r*r;
}
function circleCircle(ax,ay,ar,bx,by,br){
  const dx=ax-bx, dy=ay-by, rr=ar+br;
  return (dx*dx+dy*dy) <= rr*rr;
}
function hexToRgb(h){
  const s = String(h||"").trim().replace("#","");
  const m = (s.length===3) ? (s[0]+s[0]+s[1]+s[1]+s[2]+s[2]) : s;
  const n = parseInt(m,16);
  if (!Number.isFinite(n)) return {r:255,g:255,b:255};
  return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};
}
function lerpC(a,b,t){ return {r:lerp(a.r,b.r,t), g:lerp(a.g,b.g,t), b:lerp(a.b,b.b,t)}; }
function rgb(c,a=1){ return `rgba(${c.r|0},${c.g|0},${c.b|0},${a})`; }
function shade(c,f){ return {r:clamp(c.r*f,0,255), g:clamp(c.g*f,0,255), b:clamp(c.b*f,0,255)}; }

/* HSL helper for rainbow trail */
function hsla(h,s,l,a){
  h = ((h%360)+360)%360;
  return `hsla(${h},${clamp(s,0,100)}%,${clamp(l,0,100)}%,${clamp(a,0,1)})`;
}

/* ---------------- State ---------------- */
const STATE = Object.freeze({ MENU:0, PLAY:1, OVER:2 });
let state = STATE.MENU;

/* ---------------- Game objects ---------------- */
let W=1,H=1,DPR=1;

function resize(){
  DPR = Math.min(window.devicePixelRatio||1, 2);
  const cssW = Math.max(1, innerWidth);
  const cssH = Math.max(1, innerHeight);
  canvas.style.width = cssW+"px";
  canvas.style.height = cssH+"px";
  canvas.width = Math.floor(cssW*DPR);
  canvas.height = Math.floor(cssH*DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.imageSmoothingEnabled = true;
  W = cssW; H = cssH;
  computePlayerSize();
  initBackground();
}
addEventListener("resize", resize);

const bgDots = [];
function initBackground(){
  bgDots.length = 0;
  const n = Math.floor(clamp((W*H)/11000, 80, 220));
  for (let i=0;i<n;i++){
    bgDots.push({x:Math.random()*W,y:Math.random()*H,r:rand(.8,2.2),s:rand(4,22)});
  }
}

/* -------- Player -------- */
const player = {
  x:0,y:0,vx:0,vy:0,
  w:48,h:48,r:18,
  lastX:0,lastY:-1,
  invT:0,
  dashT:0, dashVX:0, dashVY:0
};
function computePlayerSize(){
  const base = Math.min(W,H);
  const target = clamp(base*CFG.player.sizeScale, CFG.player.sizeMin, CFG.player.sizeMax);
  const iw = playerImg.naturalWidth || 1;
  const ih = playerImg.naturalHeight || 1;
  player.w = target;
  player.h = target*(ih/iw);
  player.r = Math.min(player.w,player.h)*CFG.player.radiusScale;
}
function resetPlayer(){
  player.x = W*0.5; player.y = H*0.5;
  player.vx=0; player.vy=0;
  player.invT=0; player.dashT=0;
  player.lastX=0; player.lastY=-1;
}
function updatePlayer(dt){
  if (player.invT>0) player.invT = Math.max(0, player.invT-dt);
  if (player.dashT>0) player.dashT = Math.max(0, player.dashT-dt);

  let dx=0,dy=0;
  if (keys.KeyW) dy-=1;
  if (keys.KeyS) dy+=1;
  if (keys.KeyA) dx-=1;
  if (keys.KeyD) dx+=1;
  const n = norm2(dx,dy);
  if (n.len>0){ player.lastX=n.x; player.lastY=n.y; }

  if (player.dashT>0){
    if (n.len>0){ player.dashVX = n.x; player.dashVY = n.y; }
    const dashSpeed = Math.max(0, Number(CFG.skills.dash.speed)||0);
    player.vx = player.dashVX * dashSpeed;
    player.vy = player.dashVY * dashSpeed;
  } else {
    const maxS = Number(CFG.player.maxSpeed)||0;
    const accel = Number(CFG.player.accel)||0;
    const fr = Number(CFG.player.friction)||0;

    const tvx = n.x*maxS, tvy = n.y*maxS;
    player.vx = approach(player.vx, tvx, accel*dt);
    player.vy = approach(player.vy, tvy, accel*dt);

    if (n.len===0){
      const damp = Math.exp(-fr*dt);
      player.vx *= damp; player.vy *= damp;
    }
  }

  player.x += player.vx*dt;
  player.y += player.vy*dt;

  const pad = player.r+2;
  player.x = clamp(player.x, pad, W-pad);
  player.y = clamp(player.y, pad, H-pad);
}

/* -------- Pipes / Gates / Orbs / FX -------- */
class Pipe{
  constructor(x,y,w,h,vx,vy){
    this.x=x; this.y=y; this.w=w; this.h=h;
    this.vx=vx; this.vy=vy;
    this.entered=false; this.scored=false;
  }
  cx(){ return this.x+this.w*0.5; }
  cy(){ return this.y+this.h*0.5; }
  update(dt, slowMul){
    const m = slowMul==null?1:slowMul;
    this.x += this.vx*dt*m;
    this.y += this.vy*dt*m;
    if (!this.entered){
      if (this.x+this.w>=0 && this.x<=W && this.y+this.h>=0 && this.y<=H) this.entered=true;
    }
  }
  off(m){ return (this.x>W+m)||(this.x+this.w<-m)||(this.y>H+m)||(this.y+this.h<-m); }
}
class Gate{
  constructor(axis, pos, v, gapCenter, gapHalf, thick){
    this.axis=axis; this.pos=pos; this.prev=pos; this.v=v;
    this.gapCenter=gapCenter; this.gapHalf=gapHalf; this.thick=thick;
    this.entered=false; this.cleared=false;
  }
  update(dt){
    this.prev=this.pos;
    this.pos+=this.v*dt;
    if (!this.entered){
      if (this.axis==="x"){
        if (this.pos+this.thick*0.5>=0 && this.pos-this.thick*0.5<=W) this.entered=true;
      } else {
        if (this.pos+this.thick*0.5>=0 && this.pos-this.thick*0.5<=H) this.entered=true;
      }
    }
  }
  crossed(playerAxis){
    if (this.cleared || !this.entered) return false;
    if (this.v>0) return (this.prev<playerAxis && this.pos>=playerAxis);
    if (this.v<0) return (this.prev>playerAxis && this.pos<=playerAxis);
    return false;
  }
  off(m){ return this.axis==="x" ? (this.pos<-m||this.pos>W+m) : (this.pos<-m||this.pos>H+m); }
}
class Orb{
  constructor(x,y,vx,vy,r,life){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.r=r; this.life=life; this.max=life;
    this.ph = rand(0,Math.PI*2);
  }
  update(dt){
    this.life -= dt;
    this.ph += dt*2.2;
    this.x += this.vx*dt;
    this.y += this.vy*dt;
    const pad=this.r+4;
    if (this.x<pad){ this.x=pad; this.vx=Math.abs(this.vx); }
    if (this.x>W-pad){ this.x=W-pad; this.vx=-Math.abs(this.vx); }
    if (this.y<pad){ this.y=pad; this.vy=Math.abs(this.vy); }
    if (this.y>H-pad){ this.y=H-pad; this.vy=-Math.abs(this.vy); }
  }
  dead(){ return this.life<=0; }
}
class Part{
  constructor(x,y,vx,vy,life,size,color,add){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.life=life; this.max=life; this.size=size;
    this.color=color; this.add=add; this.drag=0;
  }
  update(dt){
    this.life-=dt; if (this.life<=0) return;
    if (this.drag>0){ const d=Math.exp(-this.drag*dt); this.vx*=d; this.vy*=d; }
    this.x+=this.vx*dt; this.y+=this.vy*dt;
  }
  draw(){
    if (this.life<=0) return;
    const t=clamp(this.life/this.max,0,1), a=t*t;
    ctx.save();
    if (this.add) ctx.globalCompositeOperation="lighter";
    ctx.globalAlpha=a;
    ctx.fillStyle=this.color;
    ctx.beginPath(); ctx.arc(this.x,this.y,Math.max(.7,this.size*(.6+.6*(1-t))),0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}
class FloatText{
  constructor(txt,x,y,color){
    this.txt=txt; this.x=x; this.y=y;
    this.vx=rand(-18,18); this.vy=rand(-90,-55);
    this.life=.9; this.max=.9;
    this.color=color||"rgba(255,255,255,.95)";
    this.size=18;
  }
  update(dt){
    this.life-=dt; if (this.life<=0) return;
    this.x+=this.vx*dt; this.y+=this.vy*dt;
    const d=Math.exp(-2.7*dt); this.vx*=d; this.vy*=d;
  }
  draw(){
    if (this.life<=0) return;
    const t=clamp(this.life/this.max,0,1), a=t*t;
    ctx.save();
    ctx.globalAlpha=a;
    ctx.font=`900 ${this.size}px system-ui,-apple-system,Segoe UI,Roboto,sans-serif`;
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.shadowColor="rgba(0,0,0,.55)"; ctx.shadowBlur=14; ctx.shadowOffsetY=2;
    ctx.fillStyle=this.color;
    ctx.fillText(this.txt,this.x,this.y);
    ctx.restore();
  }
}

/* ---------------- Gameplay vars ---------------- */
let pipes=[], gates=[], orbs=[], parts=[], floats=[];
let score=0, best=readLocalBest();
let timeAlive=0;
let pipeT=0, specialT=1.6, orbT=1.0;
let combo=0, comboBreakFlash=0, comboSparkAcc=0;
let perfectT=0, perfectMax=0;
let slowField=null; // {x,y,r,fac,t,tm}
let cds={ dash:0, phase:0, teleport:0, slowField:0 };

// Trail state
let trailId = "classic";
let trailAcc = 0;
let trailHue = 0;

const margin = ()=> clamp(Math.min(W,H)*0.25, 110, 240);

function difficulty01(){
  const t=timeAlive, s=score;
  const tc=Math.max(1e-3, Number(CFG.pipes.difficulty.timeToMax)||38);
  const sc=Math.max(1e-3, Number(CFG.pipes.difficulty.scoreToMax)||120);
  const mt=clamp(Number(CFG.pipes.difficulty.mixTime)||0.55,0,1);
  const ms=clamp(Number(CFG.pipes.difficulty.mixScore)||0.45,0,1);
  const dT=1-Math.exp(-(t/tc));
  const dS=1-Math.exp(-(s/sc));
  return clamp(mt*dT + ms*dS, 0, 1);
}
function spawnInterval(){
  const d=difficulty01(), si=CFG.pipes.spawnInterval;
  return clamp(lerp(si.start, si.end, d), si.min, si.max);
}
function pipeSpeed(){ const d=difficulty01(); return lerp(CFG.pipes.speed.start, CFG.pipes.speed.end, d); }
function thickness(){
  const base=Math.min(W,H), th=CFG.pipes.thickness;
  return clamp(base*th.scale, th.min, th.max);
}
function gapSize(){
  const d=difficulty01(), base=Math.min(W,H), g=CFG.pipes.gap;
  return clamp(lerp(base*g.startScale, base*g.endScale, d), g.min, g.max);
}
function pipeColor(){
  const d=difficulty01(), col=CFG.pipes.colors;
  const g=hexToRgb(col.green), b=hexToRgb(col.blue), y=hexToRgb(col.yellow), r=hexToRgb(col.red);
  if (d<0.33) return lerpC(g,b,d/0.33);
  if (d<0.66) return lerpC(b,y,(d-0.33)/0.33);
  return lerpC(y,r,(d-0.66)/0.34);
}

/* ---------------- Spawning patterns ---------------- */
function spawnSinglePipe(opts){
  const th=thickness();
  const len=clamp(th*rand(3.0,6.5), th*2.6, Math.max(W,H)*0.55);
  const spd=opts?.speed ?? pipeSpeed();
  const side=(typeof opts?.side==="number") ? opts.side : (Math.random()*4)|0;

  let x=0,y=0,vx=0,vy=0,pw=0,ph=0;
  if (side===0){ pw=th; ph=len; x=-pw-12; y=rand(-ph*0.15,H-ph*0.85); vx=spd; vy=rand(-spd*0.28,spd*0.28); }
  if (side===1){ pw=th; ph=len; x=W+12; y=rand(-ph*0.15,H-ph*0.85); vx=-spd; vy=rand(-spd*0.28,spd*0.28); }
  if (side===2){ pw=len; ph=th; x=rand(-pw*0.15,W-pw*0.85); y=-ph-12; vx=rand(-spd*0.28,spd*0.28); vy=spd; }
  if (side===3){ pw=len; ph=th; x=rand(-pw*0.15,W-pw*0.85); y=H+12; vx=rand(-spd*0.28,spd*0.28); vy=-spd; }

  if (opts?.aimAtPlayer){
    const px=player.x, py=player.y;
    const cx = (side===0)?(-th*0.5):(side===1)?(W+th*0.5):rand(0,W);
    const cy = (side===2)?(-th*0.5):(side===3)?(H+th*0.5):rand(0,H);
    const d0=norm2(px-cx,py-cy);
    const spread = (opts?.spreadRad!=null)?opts.spreadRad:rand(-.22,.22);
    const cs=Math.cos(spread), sn=Math.sin(spread);
    const ux=d0.x*cs-d0.y*sn, uy=d0.x*sn+d0.y*cs;
    vx=ux*spd; vy=uy*spd;
    if (side===0){ x=-pw-14; y=clamp(cy-ph*0.5,-ph,H+ph); }
    if (side===1){ x=W+14; y=clamp(cy-ph*0.5,-ph,H+ph); }
    if (side===2){ y=-ph-14; x=clamp(cx-pw*0.5,-pw,W+pw); }
    if (side===3){ y=H+14; x=clamp(cx-pw*0.5,-pw,W+pw); }
  }
  pipes.push(new Pipe(x,y,pw,ph,vx,vy));
}
function spawnWall(opts){
  const th=thickness();
  const spd=opts?.speed ?? (pipeSpeed()*0.95);
  const gap=opts?.gap ?? gapSize();
  const side=(typeof opts?.side==="number") ? opts.side : (Math.random()*4)|0;
  const pad = Math.max(18, player.r*1.1);

  if (side===0||side===1){
    const gc=rand(pad+gap*0.5, H-(pad+gap*0.5));
    const top=gc-gap*0.5, bot=gc+gap*0.5;
    const topLen=clamp(top,10,H), botLen=clamp(H-bot,10,H);
    const sx=(side===0)?(-th-16):(W+16);
    const vx=(side===0)?spd:-spd;
    if (topLen>10) pipes.push(new Pipe(sx,0,th,topLen,vx,0));
    if (botLen>10) pipes.push(new Pipe(sx,bot,th,botLen,vx,0));
    gates.push(new Gate("x", sx+th*0.5, vx, gc, gap*0.5, th));
  } else {
    const gc=rand(pad+gap*0.5, W-(pad+gap*0.5));
    const left=gc-gap*0.5, right=gc+gap*0.5;
    const leftLen=clamp(left,10,W), rightLen=clamp(W-right,10,W);
    const sy=(side===2)?(-th-16):(H+16);
    const vy=(side===2)?spd:-spd;
    if (leftLen>10) pipes.push(new Pipe(0,sy,leftLen,th,0,vy));
    if (rightLen>10) pipes.push(new Pipe(right,sy,rightLen,th,0,vy));
    gates.push(new Gate("y", sy+th*0.5, vy, gc, gap*0.5, th));
  }
}
function spawnBurst(){
  const d=difficulty01();
  const side=(Math.random()*4)|0;
  const count=Math.floor(lerp(5,8,d));
  const spd=pipeSpeed()*lerp(.92,1.12,d);
  const arc=lerp(.65,.95,d);
  for (let i=0;i<count;i++){
    const t=(count===1)?0.5:i/(count-1);
    const spread=(t-.5)*arc;
    spawnSinglePipe({side, speed:spd, aimAtPlayer:true, spreadRad:spread});
  }
}
function spawnCrossfire(){
  const d=difficulty01();
  const spd=pipeSpeed()*lerp(.95,1.10,d);
  spawnSinglePipe({side:0,speed:spd,aimAtPlayer:true,spreadRad:rand(-.1,.1)});
  spawnSinglePipe({side:1,speed:spd,aimAtPlayer:true,spreadRad:rand(-.1,.1)});
  spawnSinglePipe({side:2,speed:spd,aimAtPlayer:true,spreadRad:rand(-.1,.1)});
  spawnSinglePipe({side:3,speed:spd,aimAtPlayer:true,spreadRad:rand(-.1,.1)});
}

/* ---------------- Orbs ---------------- */
function spawnOrb(){
  const o=CFG.catalysts.orbs;
  if (!o.enabled) return;
  if (orbs.length >= o.maxOnScreen) return;

  const r=clamp(Number(o.radius)||12,6,40);
  const life=clamp(Number(o.lifetime)||10,1,60);
  const safe=clamp(Number(o.safeDistance)||120,0,800);

  let x=W*0.5,y=H*0.5;
  for (let i=0;i<18;i++){
    const px=rand(r+10,W-r-10), py=rand(r+10,H-r-10);
    if (Math.hypot(px-player.x, py-player.y) >= (player.r+r+safe)){ x=px; y=py; break; }
  }
  const sp=rand(o.driftSpeedMin, o.driftSpeedMax);
  const a=rand(0,Math.PI*2);
  orbs.push(new Orb(x,y,Math.cos(a)*sp,Math.sin(a)*sp,r,life));
}
function orbPoints(comboNow){
  const base=Math.max(0, Number(CFG.scoring.orbBase)||0);
  const bonus=Math.max(0, Number(CFG.scoring.orbComboBonus)||0);
  return Math.round(base + bonus*Math.max(0, comboNow-1));
}
function breakCombo(x,y){
  if (combo>0) floats.push(new FloatText("COMBO BROKE", x,y, "rgba(255,90,90,.95)"));
  combo=0; comboBreakFlash=.35;
}

/* ---------------- Skills ---------------- */
function tickCooldowns(dt){
  cds.dash=Math.max(0, cds.dash-dt);
  cds.phase=Math.max(0, cds.phase-dt);
  cds.teleport=Math.max(0, cds.teleport-dt);
  cds.slowField=Math.max(0, cds.slowField-dt);
}
function useSkill(slot){
  const binds = CFG.skills.bindings;
  const name = binds && binds[slot] ? String(binds[slot]) : null;
  if (!name) return;
  if (cds[name]>0) return;

  if (name==="dash"){
    const d=CFG.skills.dash;
    const dur=clamp(Number(d.duration)||0, 0, 1.2);
    let ix=0,iy=0;
    if (keys.KeyW) iy-=1; if (keys.KeyS) iy+=1; if (keys.KeyA) ix-=1; if (keys.KeyD) ix+=1;
    const n=norm2(ix,iy);
    const dx=(n.len>0)?n.x:player.lastX;
    const dy=(n.len>0)?n.y:player.lastY;
    const nn=norm2(dx,dy);
    player.dashVX = (nn.len>0)?nn.x:0;
    player.dashVY = (nn.len>0)?nn.y:-1;
    player.dashT = dur;
    cds.dash = Math.max(0, Number(d.cooldown)||0);

    for (let i=0;i<18;i++){
      const a=rand(0,Math.PI*2), sp=rand(40,260);
      const vx=Math.cos(a)*sp - player.dashVX*220;
      const vy=Math.sin(a)*sp - player.dashVY*220;
      const p=new Part(player.x,player.y,vx,vy,rand(.18,.34),rand(1.0,2.2),"rgba(255,255,255,.80)",true);
      p.drag=9.5; parts.push(p);
    }
  }

  if (name==="phase"){
    const p=CFG.skills.phase;
    const dur=clamp(Number(p.duration)||0, 0, 2.0);
    player.invT = Math.max(player.invT, dur);
    cds.phase = Math.max(0, Number(p.cooldown)||0);
    floats.push(new FloatText("PHASE", player.x, player.y-player.r*1.6, "rgba(160,220,255,.95)"));
  }

  if (name==="teleport"){
    const t=CFG.skills.teleport;
    const range=clamp(Number(t.range)||0, 0, 600);
    const ed=clamp(Number(t.effectDuration)||0.35, 0.1, 1.2);
    const burst=Math.floor(clamp(Number(t.burstParticles)||0, 0, 240));

    let dx,dy;
    if (cursor.has){ dx=cursor.x-player.x; dy=cursor.y-player.y; }
    else { dx=player.lastX; dy=player.lastY; }
    const n=norm2(dx,dy);
    const ux=(n.len>0)?n.x:player.lastX;
    const uy=(n.len>0)?n.y:player.lastY;

    const pad=player.r+2;
    const ox=player.x, oy=player.y;
    const nx=clamp(player.x + ux*range, pad, W-pad);
    const ny=clamp(player.y + uy*range, pad, H-pad);

    for (let i=0;i<burst;i++){
      const a0=rand(0,Math.PI*2), sp0=rand(80,420);
      const p0=new Part(ox,oy,Math.cos(a0)*sp0,Math.sin(a0)*sp0,rand(.22,.50),rand(1.0,2.2),"rgba(210,170,255,.92)",true);
      p0.drag=7.5; parts.push(p0);
      const a1=rand(0,Math.PI*2), sp1=rand(80,420);
      const p1=new Part(nx,ny,Math.cos(a1)*sp1,Math.sin(a1)*sp1,rand(.22,.55),rand(1.0,2.4),"rgba(255,255,255,.82)",true);
      p1.drag=7.0; parts.push(p1);
    }

    player.x=nx; player.y=ny;
    player.vx*=0.25; player.vy*=0.25;

    cds.teleport = Math.max(0, Number(t.cooldown)||0);
    floats.push(new FloatText("TELEPORT", player.x, player.y-player.r*1.7, "rgba(230,200,255,.95)"));

    for (let i=0;i<26;i++){
      const a=rand(0,Math.PI*2), sp=rand(40,160);
      const p=new Part(nx,ny,Math.cos(a)*sp,Math.sin(a)*sp,ed,rand(.9,1.7),"rgba(255,255,255,.45)",true);
      p.drag=10; parts.push(p);
    }
  }

  if (name==="slowField"){
    const s=CFG.skills.slowField;
    const dur=clamp(Number(s.duration)||0, 0, 8.0);
    const rad=clamp(Number(s.radius)||0, 40, 900);
    const fac=clamp(Number(s.slowFactor)||0.6, 0.10, 1.0);
    slowField = { x:player.x, y:player.y, r:rad, fac:fac, t:dur, tm:dur };
    cds.slowField = Math.max(0, Number(s.cooldown)||0);
    floats.push(new FloatText("SLOW FIELD", player.x, player.y-player.r*1.8, "rgba(120,210,255,.95)"));
  }
}

/* ---------------- Trail cosmetics ---------------- */
function currentTrailId(){
  if (net.user && net.user.selectedTrail) return net.user.selectedTrail;
  return trailId;
}
function trailStyle(id){
  // rate = particles/sec
  if (id==="rainbow"){
    return { rate: 95, life:[0.18,0.34], size:[0.9,2.2], speed:[35,170], drag:10.5, add:true };
  }
  if (id==="gothic"){
    return { rate: 78, life:[0.20,0.40], size:[0.9,2.4], speed:[30,150], drag:9.5, add:true };
  }
  return { rate: 55, life:[0.18,0.32], size:[0.8,2.0], speed:[25,120], drag:11.5, add:true };
}
function emitTrail(dt){
  if (state!==STATE.PLAY) return;
  const id = currentTrailId();
  const st = trailStyle(id);
  trailHue = (trailHue + dt*220) % 360;

  trailAcc += dt*st.rate;
  const n = trailAcc|0;
  trailAcc -= n;

  // direction opposite of velocity, fallback to last input
  const v = norm2(player.vx, player.vy);
  const backX = (v.len>12) ? -v.x : -player.lastX;
  const backY = (v.len>12) ? -v.y : -player.lastY;
  const bx = player.x + backX*player.r*0.95;
  const by = player.y + backY*player.r*0.95;

  for (let i=0;i<n;i++){
    const jitter = rand(0, Math.PI*2);
    const jx = Math.cos(jitter)*rand(0, player.r*0.35);
    const jy = Math.sin(jitter)*rand(0, player.r*0.35);

    const sp = rand(st.speed[0], st.speed[1]);
    const a = rand(0, Math.PI*2);
    // push particles mostly backwards, with swirl
    const vx = backX*sp + Math.cos(a)*sp*0.55;
    const vy = backY*sp + Math.sin(a)*sp*0.55;

    const life = rand(st.life[0], st.life[1]);
    const size = rand(st.size[0], st.size[1]);

    let color = "rgba(255,255,255,.70)";
    if (id==="rainbow"){
      const h = (trailHue + i*11) % 360;
      color = hsla(h, 100, 70, 0.85);
    } else if (id==="gothic"){
      // purple glow with occasional ink
      const ink = Math.random() < 0.16;
      color = ink ? "rgba(0,0,0,.55)" : "rgba(170,90,255,.72)";
    } else {
      color = "rgba(140,220,255,.62)";
    }

    const p = new Part(bx + jx, by + jy, vx, vy, life, size, color, st.add);
    p.drag = st.drag;
    parts.push(p);
  }
}

/* ---------------- UI layout (skills + combo bar) ---------------- */
function skillUI(){
  const base=Math.min(W,H);
  const size=clamp(base*0.070,46,64);
  const gap=Math.round(size*0.14);
  const pad=16;
  const x0=pad;
  const y0=H-pad-size;
  const totalW=4*size+3*gap;
  const barH=10;
  const barX=x0;
  const barY=y0-16-barH;
  return {x0,y0,size,gap,totalW,barX,barY,barW:totalW,barH};
}

/* ---------------- Game flow ---------------- */
function toMenu(){
  state = STATE.MENU;
  pipes=[]; gates=[]; orbs=[]; parts=[]; floats=[];
  score=0; timeAlive=0; pipeT=0; specialT=1.6; orbT=1.0;
  combo=0; comboBreakFlash=0; comboSparkAcc=0;
  perfectT=0; perfectMax=0;
  slowField=null;
  cds={dash:0,phase:0,teleport:0,slowField:0};
  resetPlayer();
  over.classList.add("hidden");
  menu.classList.remove("hidden");

  // refresh server data when menu shows
  refreshProfileAndHighscores();
}
function startGame(){
  state = STATE.PLAY;
  pipes=[]; gates=[]; orbs=[]; parts=[]; floats=[];
  score=0; timeAlive=0;
  pipeT=0; specialT=1.6;
  orbT = rand(CFG.catalysts.orbs.intervalMin, CFG.catalysts.orbs.intervalMax);
  combo=0; comboBreakFlash=0; comboSparkAcc=0;
  perfectT=0; perfectMax=0;
  slowField=null;
  cds={dash:0,phase:0,teleport:0,slowField:0};
  computePlayerSize();
  resetPlayer();

  // snapshot trail selection for offline play
  trailId = trailSelect.value || "classic";

  menu.classList.add("hidden");
  over.classList.add("hidden");
  window.focus();
}
async function submitScoreToServer(finalScore){
  if (!net.online || !net.user) return;
  const res = await api("/api/score", { method:"POST", body: JSON.stringify({ score: finalScore|0 }) });
  if (res && res.ok){
    net.user = res.user;
    net.trails = res.trails || net.trails;
    net.highscores = res.highscores || net.highscores;
    pbText.textContent = String(net.user.bestScore|0);
    fillTrailSelect();
    renderHighscores();
  }
}
function gameOver(){
  state = STATE.OVER;

  // local best always updates (offline support)
  const localBest = readLocalBest();
  if ((score|0) > (localBest|0)) writeLocalBest(score|0);

  finalEl.textContent = String(score|0);
  const pb = net.user ? (net.user.bestScore|0) : readLocalBest();
  overPB.textContent = String(pb|0);

  over.classList.remove("hidden");

  // async submit; UI updates if it changes PB/unlocks
  submitScoreToServer(score|0).then(()=>{
    const pb2 = net.user ? (net.user.bestScore|0) : readLocalBest();
    overPB.textContent = String(pb2|0);
  });
}

/* ---------------- Buttons ---------------- */
startBtn.addEventListener("click", startGame);
restartBtn.addEventListener("click", startGame);
toMenuBtn.addEventListener("click", toMenu);

/* ---------------- Rendering helpers ---------------- */
function roundRect(x,y,w,h,r){
  const rr=Math.min(r,w*0.5,h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}
function drawPipe(p, base){
  const edge=shade(base,0.72), hi=shade(base,1.12);
  ctx.save();
  ctx.shadowColor="rgba(0,0,0,.45)";
  ctx.shadowBlur=10;
  ctx.shadowOffsetY=3;

  const g = (p.w>=p.h)
    ? ctx.createLinearGradient(p.x,p.y,p.x+p.w,p.y)
    : ctx.createLinearGradient(p.x,p.y,p.x,p.y+p.h);
  g.addColorStop(0, rgb(edge,.95));
  g.addColorStop(.45, rgb(base,.92));
  g.addColorStop(1, rgb(hi,.95));
  ctx.fillStyle=g;
  ctx.fillRect(p.x,p.y,p.w,p.h);

  ctx.shadowBlur=0;
  ctx.strokeStyle="rgba(255,255,255,.10)";
  ctx.lineWidth=1.5;
  ctx.strokeRect(p.x+.75,p.y+.75,p.w-1.5,p.h-1.5);

  ctx.globalAlpha=.08;
  ctx.fillStyle="rgba(255,255,255,.9)";
  const step=10;
  if (p.w>=p.h){
    for (let sx=p.x+6; sx<p.x+p.w; sx+=step) ctx.fillRect(sx,p.y+2,2,p.h-4);
  } else {
    for (let sy=p.y+6; sy<p.y+p.h; sy+=step) ctx.fillRect(p.x+2,sy,p.w-4,2);
  }
  ctx.restore();
}
function drawOrb(o){
  const t=clamp(o.life/o.max,0,1);
  const pulse=.88+.12*Math.sin(o.ph);
  const r=o.r*pulse;
  ctx.save();
  ctx.shadowColor="rgba(255,255,255,.38)";
  ctx.shadowBlur=18;
  ctx.fillStyle="rgba(255,255,255,.88)";
  ctx.beginPath(); ctx.arc(o.x,o.y,r,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;
  ctx.globalAlpha=.72;
  ctx.fillStyle="rgba(120,210,255,.75)";
  ctx.beginPath(); ctx.arc(o.x,o.y,r*.55,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=.38*t;
  ctx.strokeStyle="rgba(255,255,255,.75)";
  ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(o.x,o.y,r*1.35,0,Math.PI*2); ctx.stroke();
  ctx.restore();
}
function drawPlayer(){
  ctx.save();
  ctx.shadowBlur=18;
  ctx.shadowColor = (player.invT>0) ? "rgba(160,220,255,.35)" : "rgba(120,210,255,.22)";

  if (boot.imgOk){
    ctx.drawImage(playerImg, player.x-player.w*.5, player.y-player.h*.5, player.w, player.h);
  } else {
    ctx.fillStyle="rgba(120,210,255,.92)";
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(0,0,0,.55)";
    ctx.beginPath(); ctx.arc(player.x,player.y,Math.max(2,player.r*.18),0,Math.PI*2); ctx.fill();
  }

  // Phase i-frame indicator: ring (no blink)
  if (player.invT>0){
    ctx.shadowBlur=0;
    ctx.globalAlpha=.85;
    ctx.strokeStyle="rgba(160,220,255,.95)";
    ctx.lineWidth=2.4;
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r*1.28,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=.45;
    ctx.strokeStyle="rgba(255,255,255,.85)";
    ctx.lineWidth=1.3;
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r*1.06,-Math.PI*.15,Math.PI*.15); ctx.stroke();
  }

  ctx.restore();
}
function drawPerfectFlash(){
  if (perfectT<=0) return;
  const t=clamp(perfectT/Math.max(1e-3,perfectMax),0,1);
  const a=(1-t)*(1-t);
  ctx.save();
  ctx.globalAlpha=clamp(a*.95,0,1);
  ctx.font="900 56px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
  ctx.textAlign="center"; ctx.textBaseline="top";
  ctx.shadowColor="rgba(0,0,0,.60)";
  ctx.shadowBlur=22; ctx.shadowOffsetY=4;
  ctx.fillStyle="rgba(255,255,255,.95)";
  ctx.fillText("PERFECT", W*.5, 18);
  ctx.globalAlpha=clamp(a*.25,0,1);
  ctx.fillStyle="rgba(120,210,255,.95)";
  ctx.fillText("PERFECT", W*.5+2, 18);
  ctx.restore();
}
function drawHUD(){
  // score (top-left)
  ctx.save();
  ctx.font="900 18px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
  ctx.textAlign="left"; ctx.textBaseline="top";
  ctx.shadowColor="rgba(0,0,0,.55)"; ctx.shadowBlur=12; ctx.shadowOffsetY=2;
  ctx.fillStyle="rgba(255,255,255,.92)";
  ctx.fillText(`Score: ${score|0}`, 14, 14);

  // intensity (top-right)
  ctx.textAlign="right";
  ctx.globalAlpha=.70;
  ctx.font="800 13px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
  ctx.fillText(`Intensity: ${Math.round(difficulty01()*100)}%`, W-14, 14);
  ctx.restore();

  // slow field ring
  if (slowField){
    const t=clamp(slowField.t/Math.max(1e-3,slowField.tm),0,1);
    const a=0.22+0.18*(1-t);
    ctx.save();
    ctx.globalAlpha=a;
    ctx.strokeStyle="rgba(120,210,255,.75)";
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(slowField.x,slowField.y,slowField.r,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=a*.35;
    ctx.strokeStyle="rgba(255,255,255,.60)";
    ctx.lineWidth=1;
    ctx.beginPath(); ctx.arc(slowField.x,slowField.y,slowField.r*.75,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  drawSkillBar();
}
function drawSkillIcon(skill, r){
  ctx.beginPath();
  if (skill==="dash"){
    ctx.moveTo(-r*.8,-r*.25);
    ctx.lineTo(r*.35,-r*.25);
    ctx.lineTo(r*.35,-r*.6);
    ctx.lineTo(r*.9,0);
    ctx.lineTo(r*.35,r*.6);
    ctx.lineTo(r*.35,r*.25);
    ctx.lineTo(-r*.8,r*.25);
    ctx.closePath(); ctx.fill(); ctx.stroke();
  } else if (skill==="phase"){
    ctx.moveTo(0,-r); ctx.lineTo(r,0); ctx.lineTo(0,r); ctx.lineTo(-r,0); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r*.35,0,Math.PI*2); ctx.stroke();
  } else if (skill==="teleport"){
    ctx.beginPath(); ctx.arc(0,0,r*.85,0,Math.PI*2); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-r*1.2,0); ctx.lineTo(-r*.6,0);
    ctx.moveTo(r*.6,0); ctx.lineTo(r*1.2,0);
    ctx.moveTo(0,-r*1.2); ctx.lineTo(0,-r*.6);
    ctx.moveTo(0,r*.6); ctx.lineTo(0,r*1.2);
    ctx.stroke();
  } else if (skill==="slowField"){
    ctx.beginPath(); ctx.arc(0,0,r*.9,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r*.55,-Math.PI*.25,Math.PI*.25); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r*.55,Math.PI*.75,Math.PI*1.25); ctx.stroke();
  } else {
    ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
  }
}
function drawSkillBar(){
  if (state!==STATE.PLAY) return;
  const ui = skillUI();
  const comboMax = Math.max(1, Number(CFG.scoring.orbComboMax)||30);
  const fill = clamp(combo/comboMax, 0, 1);

  // combo bar
  ctx.save();
  ctx.shadowColor="rgba(0,0,0,.50)";
  ctx.shadowBlur=12; ctx.shadowOffsetY=3;

  ctx.fillStyle="rgba(255,255,255,.08)";
  roundRect(ui.barX, ui.barY, ui.barW, ui.barH, 999); ctx.fill();

  const fillW = ui.barW*fill;
  if (fillW>0.5){
    const glowAt = Number(CFG.ui.comboBar.glowAt)||9999;
    const sparkleAt = Number(CFG.ui.comboBar.sparkleAt)||9999;
    ctx.shadowBlur = (combo>=glowAt) ? 18 : 8;
    ctx.shadowColor = (combo>=glowAt) ? "rgba(255,255,255,.25)" : "rgba(120,210,255,.20)";
    const g = ctx.createLinearGradient(ui.barX, ui.barY, ui.barX+ui.barW, ui.barY);
    g.addColorStop(0,"rgba(120,210,255,.70)");
    g.addColorStop(.6,(combo>=sparkleAt)?"rgba(255,255,255,.75)":"rgba(255,255,255,.45)");
    g.addColorStop(1,"rgba(255,255,255,.22)");
    ctx.fillStyle=g;
    roundRect(ui.barX, ui.barY, fillW, ui.barH, 999); ctx.fill();
  }

  ctx.shadowBlur=0;
  ctx.globalAlpha=.85;
  ctx.font="800 12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
  ctx.textAlign="left"; ctx.textBaseline="bottom";
  ctx.fillStyle="rgba(255,255,255,.70)";
  ctx.fillText(`COMBO ${combo}`, ui.barX, ui.barY-2);

  if (comboBreakFlash>0){
    const a=clamp(comboBreakFlash/.35,0,1);
    ctx.globalAlpha=a*.55;
    ctx.strokeStyle="rgba(255,90,90,.85)";
    ctx.lineWidth=2;
    roundRect(ui.barX-2, ui.barY-2, ui.barW+4, ui.barH+4, 999); ctx.stroke();
  }

  // skill slots
  const binds = CFG.skills.bindings;
  for (let i=0;i<4;i++){
    const x = ui.x0 + i*(ui.size+ui.gap);
    const y = ui.y0;

    ctx.globalAlpha=1;
    ctx.shadowColor="rgba(0,0,0,.50)";
    ctx.shadowBlur=12; ctx.shadowOffsetY=3;
    ctx.fillStyle="rgba(255,255,255,.08)";
    roundRect(x,y,ui.size,ui.size,12); ctx.fill();

    ctx.shadowBlur=0;
    ctx.strokeStyle="rgba(255,255,255,.16)";
    ctx.lineWidth=1.5;
    roundRect(x,y,ui.size,ui.size,12); ctx.stroke();

    // key label
    ctx.fillStyle="rgba(255,255,255,.70)";
    ctx.font="900 12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
    ctx.textAlign="left"; ctx.textBaseline="top";
    ctx.fillText(String(i+1), x+8, y+7);

    const skill = String(binds[i]||"dash");
    const rem = Math.max(0, cds[skill]||0);
    const max = Math.max(0, Number(CFG.skills[skill]?.cooldown)||0);
    const ready = rem<=1e-6;

    // icon
    ctx.save();
    ctx.translate(x+ui.size*.55, y+ui.size*.58);
    ctx.globalAlpha = .85;
    ctx.lineWidth = 2.6;
    ctx.strokeStyle = ready ? "rgba(255,255,255,.78)" : "rgba(255,255,255,.35)";
    ctx.fillStyle = ready ? "rgba(255,255,255,.12)" : "rgba(255,255,255,.06)";
    drawSkillIcon(skill, ui.size*.22);
    ctx.restore();

    // cooldown overlay
    if (max>1e-6 && rem>0){
      const frac=clamp(rem/max,0,1);
      ctx.globalAlpha=.72;
      ctx.fillStyle="rgba(0,0,0,.55)";
      roundRect(x, y+ui.size*(1-frac), ui.size, ui.size*frac, 12); ctx.fill();

      ctx.globalAlpha=.85;
      ctx.fillStyle="rgba(255,255,255,.85)";
      ctx.font="900 12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(rem.toFixed(1), x+ui.size*.5, y+ui.size*.58);
    }
  }

  ctx.restore();
}

/* ---------------- Main update + render ---------------- */
function update(dt){
  for (const p of bgDots){ p.y += p.s*dt; if (p.y>H+10){ p.y=-10; p.x=Math.random()*W; } }

  if (state!==STATE.PLAY) return;

  timeAlive += dt;
  tickCooldowns(dt);

  if (comboBreakFlash>0) comboBreakFlash = Math.max(0, comboBreakFlash-dt);
  if (perfectT>0) perfectT = Math.max(0, perfectT-dt);

  if (slowField){
    slowField.t = Math.max(0, slowField.t-dt);
    if (slowField.t<=0) slowField=null;
  }

  updatePlayer(dt);
  emitTrail(dt);

  const sparkleAt = Number(CFG.ui.comboBar.sparkleAt)||9999;
  if (combo>=sparkleAt){
    const rate=Math.max(0, Number(CFG.ui.comboBar.sparkleRate)||0);
    comboSparkAcc += dt*rate;
    const n = comboSparkAcc|0;
    comboSparkAcc -= n;
    const ui = skillUI();
    for (let i=0;i<n;i++){
      const px=rand(ui.barX, ui.barX+ui.barW);
      const py=rand(ui.barY-8, ui.barY+ui.barH+8);
      const a=rand(0,Math.PI*2), sp=rand(20,90);
      const p=new Part(px,py,Math.cos(a)*sp,Math.sin(a)*sp,rand(.18,.35),rand(.9,1.7),"rgba(255,255,255,.7)",true);
      p.drag=10.5; parts.push(p);
    }
  } else comboSparkAcc=0;

  pipeT -= dt;
  while (pipeT<=0){
    pipeT += spawnInterval();
    const d=difficulty01();
    const r=Math.random();
    const wall = CFG.pipes.patternWeights.wall;
    const aimed = CFG.pipes.patternWeights.aimed;
    const wallChance = lerp(wall[0], wall[1], d);
    const aimedChance = lerp(aimed[0], aimed[1], d);

    if (r<wallChance) spawnWall({side:(Math.random()*4)|0, gap:gapSize(), speed:pipeSpeed()*0.95});
    else if (r<wallChance+aimedChance) spawnSinglePipe({side:(Math.random()*4)|0, aimAtPlayer:true, speed:pipeSpeed()});
    else spawnSinglePipe({side:(Math.random()*4)|0, aimAtPlayer:false, speed:pipeSpeed()});
  }

  specialT -= dt;
  if (specialT<=0){
    const r=Math.random();
    if (r<0.48) spawnBurst();
    else if (r<0.78) spawnCrossfire();
    else spawnWall({side:(Math.random()*4)|0, gap:gapSize(), speed:pipeSpeed()*1.05});

    const d=difficulty01();
    const sp=CFG.pipes.special;
    specialT = lerp(sp.startCadence, sp.endCadence, d) + rand(sp.jitterMin, sp.jitterMax);
  }

  const o=CFG.catalysts.orbs;
  if (o.enabled){
    orbT -= dt;
    if (orbT<=0){
      spawnOrb();
      const a=Math.min(o.intervalMin,o.intervalMax), b=Math.max(o.intervalMin,o.intervalMax);
      orbT = rand(a,b);
    }
  }

  for (const g of gates) g.update(dt);
  if (CFG.scoring.perfect.enabled){
    const bonus=Math.max(0, Number(CFG.scoring.perfect.bonus)||0);
    const wS=clamp(Number(CFG.scoring.perfect.windowScale)||0.075, 0, 1);
    for (const g of gates){
      if (g.cleared) continue;
      const pAxis = (g.axis==="x") ? player.x : player.y;
      if (g.crossed(pAxis)){
        g.cleared=true;
        const perp = (g.axis==="x") ? player.y : player.x;
        const dist = Math.abs(perp - g.gapCenter);
        const thresh = Math.max(3, g.gapHalf*wS);
        if (dist<=thresh){
          score += bonus;
          const fd=clamp(Number(CFG.scoring.perfect.flashDuration)||0.55, .15, 2.0);
          perfectT = fd; perfectMax = fd;
          floats.push(new FloatText(`+${bonus}`, player.x, player.y-player.r*2.0, "rgba(255,255,255,.95)"));
          for (let k=0;k<28;k++){
            const a=rand(0,Math.PI*2), sp=rand(60,320);
            const p=new Part(player.x,player.y,Math.cos(a)*sp,Math.sin(a)*sp,rand(.20,.45),rand(1.0,2.2),"rgba(255,255,255,.85)",true);
            p.drag=8.5; parts.push(p);
          }
        }
      }
    }
  }

  for (const p of pipes){
    let mul=1;
    if (slowField){
      const dx=p.cx()-slowField.x, dy=p.cy()-slowField.y;
      if ((dx*dx+dy*dy) <= slowField.r*slowField.r) mul = slowField.fac;
    }
    p.update(dt, mul);
  }

  let expired=false;
  for (let i=orbs.length-1;i>=0;i--){
    orbs[i].update(dt);
    if (orbs[i].dead()){ orbs.splice(i,1); expired=true; }
  }
  if (expired){
    const ui=skillUI();
    breakCombo(ui.barX+ui.barW*0.5, ui.barY-10);
  }

  for (let i=orbs.length-1;i>=0;i--){
    const ob=orbs[i];
    if (circleCircle(player.x,player.y,player.r, ob.x,ob.y, ob.r)){
      orbs.splice(i,1);
      const maxC=Math.max(1, Number(CFG.scoring.orbComboMax)||30);
      combo = Math.min(maxC, combo+1);
      const pts = orbPoints(combo);
      score += pts;
      const col = (combo >= (Number(CFG.ui.comboBar.glowAt)||9999)) ? "rgba(255,255,255,.98)" : "rgba(120,210,255,.95)";
      floats.push(new FloatText(`+${pts}`, ob.x, ob.y, col));
      for (let k=0;k<18;k++){
        const a=rand(0,Math.PI*2), sp=rand(40,240);
        const p=new Part(ob.x,ob.y,Math.cos(a)*sp,Math.sin(a)*sp,rand(.18,.38),rand(1.0,2.0),"rgba(255,255,255,.7)",true);
        p.drag=10; parts.push(p);
      }
    }
  }

  if (player.invT<=0){
    for (const p of pipes){
      if (circleRect(player.x,player.y,player.r,p.x,p.y,p.w,p.h)){ gameOver(); return; }
    }
  }

  const m=margin();
  for (let i=pipes.length-1;i>=0;i--){
    const p=pipes[i];
    if (p.off(m)){
      if (!p.scored && p.entered){
        p.scored=true;
        score += Math.max(0, Number(CFG.scoring.pipeDodge)||0);
      }
      pipes.splice(i,1);
    }
  }
  for (let i=gates.length-1;i>=0;i--) if (gates[i].off(m)) gates.splice(i,1);

  for (const p of parts) p.update(dt);
  for (const t of floats) t.update(dt);
  for (let i=parts.length-1;i>=0;i--) if (parts[i].life<=0) parts.splice(i,1);
  for (let i=floats.length-1;i>=0;i--) if (floats[i].life<=0) floats.splice(i,1);

  if (pipes.length>280) pipes.splice(0, pipes.length-280);
  if (parts.length>1100) parts.splice(0, parts.length-1100);
  if (floats.length>80) floats.splice(0, floats.length-80);
}

function render(){
  ctx.fillStyle="#07101a";
  ctx.fillRect(0,0,W,H);

  const vg=ctx.createRadialGradient(W*.5,H*.45,Math.min(W,H)*.12, W*.5,H*.5, Math.max(W,H)*.75);
  vg.addColorStop(0,"rgba(0,0,0,0)");
  vg.addColorStop(1,"rgba(0,0,0,.44)");
  ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);

  ctx.save();
  ctx.globalAlpha=.75;
  ctx.fillStyle="rgba(255,255,255,.20)";
  for (const p of bgDots){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); }
  ctx.restore();

  const pc = pipeColor();
  for (const p of pipes) drawPipe(p, pc);
  for (const o of orbs) drawOrb(o);

  for (const p of parts) p.draw();
  for (const t of floats) t.draw();

  drawPlayer();

  if (state===STATE.PLAY){
    drawHUD();
    drawPerfectFlash();
  }
}

/* ---------------- Boot + loop ---------------- */
function init(){
  resize();
  // initial menu render uses server
  toMenu();
  setUserHint();
  fillTrailSelect();
  setBootUI();
}
init();

startBtn.disabled = true;
setBootUI();

let last=0;
function frame(ts){
  const dt = clamp((ts-last)/1000, 0, 1/30);
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(frame);
}
requestAnimationFrame((t)=>{ last=t; requestAnimationFrame(frame); });
</script>
</body>
</html>
